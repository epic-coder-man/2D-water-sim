<!DOCTYPE html>
<html>
<head>
    <style>
        canvas {
            border: 1px solid black;
        }
        #fpsCounter,
        #particleCounter,
        #menu,
        #colorMenu {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
        }
        #fpsCounter {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Initially hidden */
        }
        #particleCounter {
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
        }
        #menu {
            top: 20px;
            left: 20px;
            display: none; /* Initially hidden */
        }
        #colorMenu {
            top: 20px;
            right: 20px;
            display: none; /* Initially hidden */
        }
        .menuItem {
            cursor: pointer;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
<!-- There may be an easter egg! -->
<canvas id="waterCanvas" width="600" height="400"></canvas>
<div id="fpsCounter">FPS: 0</div>
<div id="particleCounter">Particles: 0</div>
<div id="menu">
    <div class="menuItem" onclick="changeWaterColor()">Change Color</div>
    <div class="menuItem" onclick="toggleShowFPS()">Show/Hide FPS</div>
    <div class="menuItem" onclick="toggleMenu()">Resume</div>
    <div class="menuItem" onclick="resetParticles()">Reset Particles</div>
    <div class="menuItem" onclick="clearCanvas()">Clear Canvas</div>
</div>
<div id="colorMenu">
    <input type="range" min="0" max="255" value="0" id="redSlider" oninput="adjustColor('r', this.value)">
    <input type="range" min="0" max="255" value="0" id="greenSlider" oninput="adjustColor('g', this.value)">
    <input type="range" min="0" max="255" value="255" id="blueSlider" oninput="adjustColor('b', this.value)">
</div>

<script>
    const canvas = document.getElementById("waterCanvas");
    const ctx = canvas.getContext("2d");

    const particles = [];
    const groundY = canvas.height - 40;
    const bounceFactor = 0.7;
    const collisionDistance = 40;
    const repulsionDistance = 10;
    const repulsionForce = 0.1;
    const waterDampingFactor = 0.95;
    const attractionForce = 0.04;
    const gravityRate = 0.003;
    const clumpingLimit = 10;

    let waterColor = { r: 0, g: 0, b: 255 }; // Initial color is blue
    let lastRenderTime = performance.now();
    let isMenuVisible = false;
    let isColorMenuVisible = false;
    let showFPS = false;

    const spacebarCode = 32;
    const dKey = 68;
    const kKey = 75; // Key code for 'K'
    const mKey = 77; // Key code for 'M'
    const fKey = 70; // Key code for 'F'

    function initParticles(numParticles) {
        for (let i = 0; i < numParticles; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                velocityX: 0,
                velocityY: 0,
            });
        }
    }

    function handleMouseMove(e) {
        const mouseX = e.clientX - canvas.getBoundingClientRect().left;
        const mouseY = e.clientY - canvas.getBoundingClientRect().top;

        particles.forEach((particle) => {
            const dx = particle.x - mouseX;
            const dy = particle.y - mouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < collisionDistance) {
                const angle = Math.atan2(dy, dx);
                const overlap = collisionDistance - distance;

                particle.x += overlap * Math.cos(angle);
                particle.y += overlap * Math.sin(angle);
            }
        });
    }

    function handleMouseClick(e) {
        const mouseX = e.clientX - canvas.getBoundingClientRect().left;
        const mouseY = e.clientY - canvas.getBoundingClientRect().top;

        particles.forEach((particle) => {
            const dx = particle.x - mouseX;
            const dy = particle.y - mouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 100) {
                const angle = Math.atan2(dy, dx);

                particle.velocityX += 5 * Math.cos(angle);
                particle.velocityY += 5 * Math.sin(angle);
            }
        });
    }

    function handleKeyDown(event) {
        if (event.keyCode === spacebarCode) {
            particles.push({
                x: canvas.width / 2,
                y: canvas.height / 2,
                velocityX: 0,
                velocityY: 0,
            });
        } else if (event.keyCode === dKey) {
            particles.pop();
        } else if (event.keyCode === kKey) {
            // Explode water when 'K' key is pressed
            particles.forEach((particle) => {
                particle.velocityX *= 100; // Increase velocity in x direction
                particle.velocityY *= 100; // Increase velocity in y direction
            });
        } else if (event.keyCode === mKey) {
            toggleMenu(); // Show/hide menu when 'M' key is pressed
        } else if (event.keyCode === fKey) {
            toggleColorMenu(); // Show/hide color menu when 'F' key is pressed
        }
    }

    function drawParticles() {
        particles.forEach((particle) => {
            let isFarAway = true;
            for (let i = 0; i < particles.length; i++) {
                if (particle !== particles[i]) {
                    const dx = particles[i].x - particle.x;
                    const dy = particles[i].y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < collisionDistance) {
                        isFarAway = false;
                        break;
                    }
                }
            }
            if (isFarAway) {
                ctx.fillStyle = `rgb(${waterColor.r}, ${waterColor.g}, ${waterColor.b})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    function drawLines() {
        ctx.strokeStyle = `rgb(${waterColor.r}, ${waterColor.g}, ${waterColor.b})`;
        ctx.lineWidth = 4; // Thicker lines
        for (let i = 0; i < particles.length; i++) {
            for (let j = i + 1; j < particles.length; j++) {
                const particleA = particles[i];
                const particleB = particles[j];

                const dx = particleA.x - particleB.x;
                const dy = particleA.y - particleB.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 40) {
                    ctx.beginPath();
                    ctx.moveTo(particleA.x, particleA.y);
                    ctx.lineTo(particleB.x, particleB.y);
                    ctx.stroke();

                    const angle = Math.atan2(dy, dx);

                    particleA.velocityX += attractionForce * Math.cos(angle);
                    particleA.velocityY += attractionForce * Math.sin(angle);
                    particleB.velocityX -= attractionForce * Math.cos(angle);
                    particleB.velocityY -= attractionForce * Math.sin(angle);
                }
            }
        }
    }

    function updateParticles() {
        particles.forEach((particle, index) => {
            const gravity = 0.2 + gravityRate * particle.y;

            particle.velocityY += gravity;

            if (particle.y >= groundY) {
                particle.y = groundY;
                if (Math.abs(particle.velocityY) < 1) {
                    particle.velocityY = 0;
                } else {
                    particle.velocityY *= -bounceFactor;
                }
            }

            for (let i = 0; i < particles.length; i++) {
                if (i !== index) {
                    const otherParticle = particles[i];
                    const dx = otherParticle.x - particle.x;
                    const dy = otherParticle.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < clumpingLimit) {
                        const angle = Math.atan2(dy, dx);
                        const overlap = clumpingLimit - distance;

                        particle.x -= overlap / 2 * Math.cos(angle);
                        particle.y -= overlap / 2 * Math.sin(angle);
                        otherParticle.x += overlap / 2 * Math.cos(angle);
                        otherParticle.y += overlap / 2 * Math.sin(angle);

                        const relativeVelocityX = particle.velocityX - otherParticle.velocityX;
                        const relativeVelocityY = particle.velocityY - otherParticle.velocityY;

                        const impulseX = (1 + bounceFactor) * relativeVelocityX / 2;
                        const impulseY = (1 + bounceFactor) * relativeVelocityY / 2;

                        particle.velocityX -= impulseX * waterDampingFactor;
                        particle.velocityY -= impulseY * waterDampingFactor;

                        otherParticle.velocityX += impulseX * waterDampingFactor;
                        otherParticle.velocityY += impulseY * waterDampingFactor;
                    }

                    if (distance < repulsionDistance) {
                        const angle = Math.atan2(dy, dx);

                        particle.velocityX += repulsionForce * Math.cos(angle);
                        particle.velocityY += repulsionForce * Math.sin(angle);
                    }
                }
            }

            particle.x += particle.velocityX;
            particle.y += particle.velocityY;

            particle.x = Math.min(canvas.width, Math.max(0, particle.x));
        });
    }

    function drawFPS() {
        if (showFPS) {
            const now = performance.now();
            const elapsed = now - lastRenderTime;
            const fps = Math.round(1000 / elapsed);
            const fpsCounter = document.getElementById("fpsCounter");
            fpsCounter.textContent = `FPS: ${fps}`;
            fpsCounter.style.display = "block"; // Ensure FPS counter is visible
        } else {
            document.getElementById("fpsCounter").style.display = "none"; // Hide FPS counter
        }
    }

    function drawParticleCounter() {
        document.getElementById("particleCounter").textContent = `Particles: ${particles.length}`;
    }

    function changeWaterColor() {
        waterColor = getRandomColor();
        hideMenu();
    }

    function goBlue() {
        waterColor = { r: 0, g: 0, b: 255 };
        hideMenu();
    }

    function toggleShowFPS() {
        showFPS = !showFPS;
        hideMenu();
    }

    function toggleMenu() {
        isMenuVisible = !isMenuVisible;
        const menu = document.getElementById("menu");
        menu.style.display = isMenuVisible ? "block" : "none";
    }

    function toggleColorMenu() {
        isColorMenuVisible = !isColorMenuVisible;
        const colorMenu = document.getElementById("colorMenu");
        colorMenu.style.display = isColorMenuVisible ? "block" : "none";
    }

    function hideMenu() {
        isMenuVisible = false;
        const menu = document.getElementById("menu");
        menu.style.display = "none";
    }

    function hideColorMenu() {
        isColorMenuVisible = false;
        const colorMenu = document.getElementById("colorMenu");
        colorMenu.style.display = "none";
    }

    function resetParticles() {
        particles.length = 0;
        initParticles(200);
        hideMenu();
    }

    function clearCanvas() {
        particles.length = 0;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        hideMenu();
    }

    function getRandomColor() {
        return {
            r: Math.floor(Math.random() * 256),
            g: Math.floor(Math.random() * 256),
            b: Math.floor(Math.random() * 256),
        };
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "gray";
        ctx.fillRect(0, groundY, canvas.width, 40);

        updateParticles();

        drawParticles();
        drawLines();
        drawFPS();
        drawParticleCounter();

        lastRenderTime = performance.now(); // Update last render time

        requestAnimationFrame(draw);
    }

    function adjustColor(component, value) {
        waterColor[component] = parseInt(value);
    }

    // Initial setup
    initParticles(200);
    canvas.addEventListener("mousemove", handleMouseMove);
    canvas.addEventListener("click", handleMouseClick);
    document.addEventListener("keydown", handleKeyDown);

    draw();
</script>
</body>
</html>
