<!DOCTYPE html>
<html>
  <head>
    <style>
      canvas {
        border: 1px solid black;
      }
      #fpsCounter,
      #particleCounter,
      #colorChanger {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
      }
      #fpsCounter {
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
      }
      #particleCounter {
        top: 45px;
        left: 50%;
        transform: translateX(-50%);
      }
      #colorChanger {
        top: 20px;
        right: 20px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <canvas id="waterCanvas" width="600" height="400"></canvas>
    <div id="fpsCounter">FPS: 0</div>
    <div id="particleCounter">Particles: 0</div>
    <div id="colorChanger" onclick="changeWaterColor()">Change Color</div>

    <script>
      const canvas = document.getElementById("waterCanvas");
      const ctx = canvas.getContext("2d");

      const particles = [];
      const groundY = canvas.height - 40;
      const bounceFactor = 0.7;
      const collisionDistance = 40;
      const repulsionDistance = 10;
      const repulsionForce = 0.1;
      const waterDampingFactor = 0.95;
      const attractionForce = 0.04;
      const gravityRate = 0.003;
      const clumpingLimit = 10;

      let waterColor = "blue";

      const spacebarCode = 32;
      const dKey = 68;

      function initParticles(numParticles) {
        for (let i = 0; i < numParticles; i++) {
          particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            velocityX: 0,
            velocityY: 0,
          });
        }
      }

      function handleMouseMove(e) {
        const mouseX = e.clientX - canvas.getBoundingClientRect().left;
        const mouseY = e.clientY - canvas.getBoundingClientRect().top;

        particles.forEach((particle) => {
          const dx = particle.x - mouseX;
          const dy = particle.y - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < collisionDistance) {
            const angle = Math.atan2(dy, dx);
            const overlap = collisionDistance - distance;

            particle.x += overlap * Math.cos(angle);
            particle.y += overlap * Math.sin(angle);
          }
        });
      }

      function handleMouseClick(e) {
        const mouseX = e.clientX - canvas.getBoundingClientRect().left;
        const mouseY = e.clientY - canvas.getBoundingClientRect().top;

        particles.forEach((particle) => {
          const dx = particle.x - mouseX;
          const dy = particle.y - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 100) {
            const angle = Math.atan2(dy, dx);

            particle.velocityX += 5 * Math.cos(angle);
            particle.velocityY += 5 * Math.sin(angle);
          }
        });
      }

      function handleKeyDown(event) {
        if (event.keyCode === spacebarCode) {
          particles.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            velocityX: 0,
            velocityY: 0,
          });
        } else if (event.keyCode === dKey) {
          particles.pop();
        }
      }

      function drawParticles() {
        ctx.fillStyle = waterColor;
        particles.forEach((particle) => {
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawLines() {
        ctx.strokeStyle = waterColor;
        ctx.lineWidth = 4;

        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const particleA = particles[i];
            const particleB = particles[j];

            const dx = particleA.x - particleB.x;
            const dy = particleA.y - particleB.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 40) {
              ctx.beginPath();
              ctx.moveTo(particleA.x, particleA.y);
              ctx.lineTo(particleB.x, particleB.y);
              ctx.stroke();

              const angle = Math.atan2(dy, dx);

              particleA.velocityX += attractionForce * Math.cos(angle);
              particleA.velocityY += attractionForce * Math.sin(angle);
              particleB.velocityX -= attractionForce * Math.cos(angle);
              particleB.velocityY -= attractionForce * Math.sin(angle);
            }
          }
        }
      }

      function updateParticles() {
        particles.forEach((particle, index) => {
          const gravity = 0.2 + gravityRate * particle.y;

          particle.velocityY += gravity;

          if (particle.y >= groundY) {
            particle.y = groundY;
            particle.velocityY *= -bounceFactor;
          }

          for (let i = 0; i < particles.length; i++) {
            if (i !== index) {
              const otherParticle = particles[i];
              const dx = otherParticle.x - particle.x;
              const dy = otherParticle.y - particle.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < clumpingLimit) {
                const angle = Math.atan2(dy, dx);
                const overlap = clumpingLimit - distance;

                particle.x -= overlap / 2 * Math.cos(angle);
                particle.y -= overlap / 2 * Math.sin(angle);
                otherParticle.x += overlap / 2 * Math.cos(angle);
                otherParticle.y += overlap / 2 * Math.sin(angle);

                const relativeVelocityX = particle.velocityX - otherParticle.velocityX;
                const relativeVelocityY = particle.velocityY - otherParticle.velocityY;

                const impulseX = (1 + bounceFactor) * relativeVelocityX / 2;
                const impulseY = (1 + bounceFactor) * relativeVelocityY / 2;

                particle.velocityX -= impulseX * waterDampingFactor;
                particle.velocityY -= impulseY * waterDampingFactor;

                otherParticle.velocityX += impulseX * waterDampingFactor;
                otherParticle.velocityY += impulseY * waterDampingFactor;
              }

              if (distance < repulsionDistance) {
                const angle = Math.atan2(dy, dx);

                particle.velocityX += repulsionForce * Math.cos(angle);
                particle.velocityY += repulsionForce * Math.sin(angle);
              }
            }
          }

          particle.x += particle.velocityX;
          particle.y += particle.velocityY;

          particle.x = Math.min(canvas.width, Math.max(0, particle.x));
        });
      }

      function drawFPS() {
        const now = performance.now();
        const elapsed = now - lastFrameTime;
        lastFrameTime = now;
        const fps = Math.round(1000 / elapsed);
        document.getElementById("fpsCounter").textContent = `FPS: ${fps}`;
      }

      function drawParticleCounter() {
        document.getElementById("particleCounter").textContent = `Particles: ${particles.length}`;
      }

      function changeWaterColor() {
        waterColor = getRandomColor();
      }

      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "gray";
        ctx.fillRect(0, groundY, canvas.width, 40);

        updateParticles();

        drawParticles();
        drawLines();
        drawFPS();
        drawParticleCounter();

        requestAnimationFrame(draw);
      }

      // Initial setup
      initParticles(200);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("click", handleMouseClick);
      document.addEventListener("keydown", handleKeyDown);

      let lastFrameTime = performance.now();
      draw();
    </script>
  </body>
</html>
